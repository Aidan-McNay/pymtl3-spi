//-------------------------------------------------------------------------
// SPIHardbits__pack_size_128__hard_bits_4.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder SPIHardbits Definition
// At /home/km633/Research/SPI_pymtl/sim/SPI_pymtl2/MinionModules/SPIHardbits/SPIHardbits.py

//***********************************************************
// Pickled source file of placeholder SPIHardbits__pack_size_128__hard_bits_4
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder SPIHardbits
//-----------------------------------------------------------

`ifndef SPIHARDBITS
`define SPIHARDBITS

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component SPIHardbits__pack_size_128__hard_bits_4.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component SPIHardbits__pack_size_128__hard_bits_4

`line 1 "SPI_pymtl2/MinionModules/SPIHardbits/SPIHardbits.v" 0
//===========================================
// SPI Hardbits
//===========================================

`ifndef HARDBITS_V
`define HARDBITS_V


module SPI_pymtl2_MinionModules_SPIHardbits_SPIHardbits
#(
  parameter pack_size = 32,
  parameter hard_bits = 1
)(

  //control IO
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    serve,
  output logic                    hard_msg,
  
  //IO with respect to master
  input  logic [pack_size-1 : 0]  from_master,
  output logic [pack_size-1 : 0]  to_master,

  
  //detected bits
  output logic [hard_bits-1 : 0]  detected_bits,
  
  //IO with respect to device
  input  logic [pack_size-1 : 0]  from_device,
  output logic [pack_size-1 : 0]  to_device
  
); 
  // message pass through
  assign to_device = from_master;
  assign to_master = from_device;
  
  // hard_msg signal
  assign hard_msg = from_master[pack_size - 1] ? 1'b1 : 1'b0;  
  
  // detected bits
  vc_EnResetReg  #(hard_bits, 0) bit_status
  (
    .clk        (clk),
    .reset      (reset),
    .q          (detected_bits),
    .d          (from_master[pack_size - 2 : pack_size - (hard_bits + 1)]),
    .en         (from_master[pack_size - 1] & serve)                //msb will be enable signal for hardcode
  );
        
endmodule 

//////////////////////////////////////////////////////////////////////////
// includes 
//////////////////////////////////////////////////////////////////////////
    
module vc_EnResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always@( posedge clk )
    if ( reset || en )
      q <= reset ? p_reset_value : d;

endmodule

`endif /* HARDBITS_V */

`endif /* SPIHARDBITS */
//-----------------------------------------------------------
// Wrapper of placeholder SPIHardbits__pack_size_128__hard_bits_4
//-----------------------------------------------------------

`ifndef SPIHARDBITS__PACK_SIZE_128__HARD_BITS_4
`define SPIHARDBITS__PACK_SIZE_128__HARD_BITS_4

module SPIHardbits__pack_size_128__hard_bits_4
(
  input logic [1-1:0] clk ,
  output logic [4-1:0] detected_bits ,
  input logic [128-1:0] from_device ,
  input logic [128-1:0] from_master ,
  output logic [1-1:0] hard_msg ,
  input logic [1-1:0] reset ,
  input logic [1-1:0] serve ,
  output logic [128-1:0] to_device ,
  output logic [128-1:0] to_master 
);
  SPI_pymtl2_MinionModules_SPIHardbits_SPIHardbits
  #(
    .pack_size( 128 ),
    .hard_bits( 4 )
  ) v
  (
    .clk( clk ),
    .detected_bits( detected_bits ),
    .from_device( from_device ),
    .from_master( from_master ),
    .hard_msg( hard_msg ),
    .reset( reset ),
    .serve( serve ),
    .to_device( to_device ),
    .to_master( to_master )
  );
endmodule

`endif /* SPIHARDBITS__PACK_SIZE_128__HARD_BITS_4 */

